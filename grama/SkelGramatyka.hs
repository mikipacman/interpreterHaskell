module SkelGramatyka where

-- Haskell module generated by the BNF converter

import AbsGramatyka
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Program decls -> failure x
transDecl :: Decl -> Result
transDecl x = case x of
  VDecl basictype vardeclitems -> failure x
  ADecl arrtype vardeclitems -> failure x
  FDecl basictype ident funcdeclitems decls stmts expr -> failure x
transVarDeclItem :: VarDeclItem -> Result
transVarDeclItem x = case x of
  NoInit ident -> failure x
  Init ident expr -> failure x
transFuncDeclItem :: FuncDeclItem -> Result
transFuncDeclItem x = case x of
  FDItem basictype ident -> failure x
transBlock :: Block -> Result
transBlock x = case x of
  Block stmts -> failure x
transAssign :: Assign -> Result
transAssign x = case x of
  VarAs ident accs expr -> failure x
transStmt :: Stmt -> Result
transStmt x = case x of
  EmptyStmt -> failure x
  IfStmt expr block -> failure x
  IfElseStmt expr block1 block2 -> failure x
  WhileStmt expr block -> failure x
  ForStmt decl exprs assigns block -> failure x
  AsStmt assign -> failure x
  ExprStmt expr -> failure x
  SCostStmt countcost -> failure x
transBasicType :: BasicType -> Result
transBasicType x = case x of
  IntT -> failure x
  StringT -> failure x
  BoolT -> failure x
transArrType :: ArrType -> Result
transArrType x = case x of
  ArrT basictype accs -> failure x
transLiteral :: Literal -> Result
transLiteral x = case x of
  IntL integer -> failure x
  StringL string -> failure x
  TrueL -> failure x
  FalseL -> failure x
transAcc :: Acc -> Result
transAcc x = case x of
  Acc expr -> failure x
transExpr :: Expr -> Result
transExpr x = case x of
  ExprLit literal -> failure x
  ExprGC getcost -> failure x
  ExprBr expr -> failure x
  ExprCall ident exprs -> failure x
  ExprAcc ident accs -> failure x
  Neg expr -> failure x
  Not expr -> failure x
  EMul expr1 mulop expr2 -> failure x
  EAdd expr1 addop expr2 -> failure x
  ERel expr1 relop expr2 -> failure x
  EEq expr1 eqop expr2 -> failure x
  EAnd expr1 andop expr2 -> failure x
  EOr expr1 orop expr2 -> failure x
transOp :: Op -> Result
transOp x = case x of
  AOp addop -> failure x
  MOp mulop -> failure x
  ROp relop -> failure x
  EOp eqop -> failure x
  AndOp andop -> failure x
  OrOp orop -> failure x
transAddOp :: AddOp -> Result
transAddOp x = case x of
  Plus -> failure x
  Minus -> failure x
transMulOp :: MulOp -> Result
transMulOp x = case x of
  Mul -> failure x
  Div -> failure x
  Mod -> failure x
transRelOp :: RelOp -> Result
transRelOp x = case x of
  Less -> failure x
  LessEq -> failure x
  Great -> failure x
  GreatEq -> failure x
transEqOp :: EqOp -> Result
transEqOp x = case x of
  Eq -> failure x
  NotEq -> failure x
transAndOp :: AndOp -> Result
transAndOp x = case x of
  And -> failure x
transOrOp :: OrOp -> Result
transOrOp x = case x of
  Or -> failure x
transCountCost :: CountCost -> Result
transCountCost x = case x of
  CRead ident1 expr ident2 -> failure x
  CWrite ident1 expr ident2 -> failure x
  COp op expr ident -> failure x
transGetCost :: GetCost -> Result
transGetCost x = case x of
  GRead ident -> failure x
  GWrite ident -> failure x
  GOpCost op -> failure x

